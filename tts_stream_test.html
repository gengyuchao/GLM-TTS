<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GLM-TTS æµå¼è¯­éŸ³åˆæˆæµ‹è¯•</title>
<style>
/* æ ·å¼éƒ¨åˆ†ä¿æŒä¸å˜ */
* {
box-sizing: border-box;
margin: 0;
padding: 0;
}
body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
line-height: 1.6;
color: #333;
max-width: 1000px;
margin: 0 auto;
padding: 20px;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
}
.container {
background: white;
border-radius: 15px;
padding: 30px;
box-shadow: 0 10px 30px rgba(0,0,0,0.2);
margin: 20px 0;
}
header {
text-align: center;
margin-bottom: 30px;
}
h1 {
color: #2c3e50;
font-size: 2.2em;
margin-bottom: 10px;
background: linear-gradient(45deg, #667eea, #764ba2);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
}
.subtitle {
color: #7f8c8d;
font-size: 1.1em;
}
.config-section {
background: #f8f9fa;
padding: 25px;
border-radius: 12px;
margin-bottom: 25px;
border: 1px solid #e9ecef;
}
.config-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
gap: 20px;
margin-top: 15px;
}
.form-group {
margin-bottom: 15px;
}
label {
display: block;
margin-bottom: 6px;
font-weight: 600;
color: #2c3e50;
font-size: 0.95em;
}
input[type="text"],
textarea,
select,
input[type="file"] {
width: 100%;
padding: 12px 15px;
border: 2px solid #ddd;
border-radius: 8px;
font-size: 1em;
transition: border-color 0.3s;
background: white;
}
input[type="text"]:focus,
textarea:focus,
select:focus,
input[type="file"]:focus {
border-color: #667eea;
outline: none;
box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
}
textarea {
min-height: 100px;
resize: vertical;
}
.voice-options {
display: flex;
gap: 15px;
align-items: center;
flex-wrap: wrap;
}
.voice-option {
display: flex;
align-items: center;
gap: 8px;
cursor: pointer;
}
.voice-option input[type="radio"] {
width: auto;
margin: 0;
}
.control-section {
text-align: center;
margin: 30px 0;
}
.btn {
background: linear-gradient(45deg, #667eea, #764ba2);
color: white;
border: none;
padding: 14px 35px;
font-size: 1.1em;
border-radius: 10px;
cursor: pointer;
transition: all 0.3s ease;
font-weight: 600;
letter-spacing: 0.5px;
box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}
.btn:hover {
transform: translateY(-2px);
box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
}
.btn:active {
transform: translateY(0);
}
.btn:disabled {
background: #95a5a6;
cursor: not-allowed;
transform: none;
box-shadow: none;
opacity: 0.7;
}
.player-section {
background: #f8f9fa;
padding: 25px;
border-radius: 12px;
margin-top: 25px;
border: 1px solid #e9ecef;
}
.audio-player-container {
margin: 20px 0;
padding: 15px;
background: white;
border-radius: 10px;
border: 1px solid #e9ecef;
}
.custom-audio-controls {
display: flex;
align-items: center;
gap: 15px;
margin: 15px 0;
}
.playback-btn {
background: #667eea;
color: white;
border: none;
width: 45px;
height: 45px;
border-radius: 50%;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
font-size: 1.4em;
transition: all 0.2s;
flex-shrink: 0;
}
.playback-btn:hover {
background: #5a6fd8;
transform: scale(1.05);
}
.playback-btn:disabled {
background: #95a5a6;
cursor: not-allowed;
transform: none;
opacity: 0.7;
}
.progress-container {
flex: 1;
min-width: 200px;
}
.time-display {
font-family: monospace;
font-size: 1.1em;
color: #2c3e50;
width: 100px;
text-align: center;
flex-shrink: 0;
}
.progress-bar {
width: 100%;
height: 8px;
background: #e9ecef;
border-radius: 4px;
overflow: hidden;
margin-top: 5px;
position: relative;
cursor: pointer;
}
.progress-fill {
height: 100%;
background: linear-gradient(45deg, #667eea, #764ba2);
width: 0%;
transition: width 0.1s ease;
position: relative;
}
.progress-fill::after {
content: '';
position: absolute;
top: 0;
right: 0;
bottom: 0;
left: 0;
background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
animation: shimmer 1.5s infinite;
}
@keyframes shimmer {
0% { transform: translateX(-100%); }
100% { transform: translateX(100%); }
}
.volume-control {
display: flex;
align-items: center;
gap: 8px;
margin-left: 15px;
flex-shrink: 0;
}
.volume-slider {
width: 80px;
margin: 0;
}
.status {
text-align: center;
padding: 15px;
margin: 15px 0;
border-radius: 8px;
font-weight: 500;
}
.status.info {
background: #e3f2fd;
color: #1976d2;
border: 1px solid #bbdefb;
}
.status.success {
background: #e8f5e9;
color: #2e7d32;
border: 1px solid #c8e6c9;
}
.status.error {
background: #ffebee;
color: #c62828;
border: 1px solid #ffcdd2;
}
.status.processing {
background: #fff8e1;
color: #5d4037;
border: 1px solid #ffecb3;
}
.stats {
display: flex;
justify-content: space-around;
margin-top: 15px;
text-align: center;
}
.stat-item {
padding: 10px;
background: white;
border-radius: 8px;
box-shadow: 0 2px 8px rgba(0,0,0,0.1);
min-width: 120px;
}
.stat-value {
font-size: 1.4em;
font-weight: bold;
color: #667eea;
}
.stat-label {
color: #7f8c8d;
font-size: 0.9em;
}
.upload-preview {
margin-top: 10px;
padding: 10px;
background: #e8f4ff;
border-radius: 6px;
display: none;
}
.upload-preview audio {
width: 100%;
margin-top: 5px;
}
.upload-info {
font-size: 0.9em;
color: #666;
margin-top: 5px;
}
.footer {
text-align: center;
margin-top: 30px;
color: white;
opacity: 0.9;
font-size: 0.95em;
}
@media (max-width: 768px) {
.config-grid {
grid-template-columns: 1fr;
}
.voice-options {
flex-direction: column;
gap: 10px;
}
.stats {
flex-direction: column;
gap: 10px;
}
.custom-audio-controls {
flex-direction: column;
gap: 10px;
}
.time-display {
width: 100%;
}
.volume-control {
width: 100%;
justify-content: center;
}
}
</style>
</head>
<body>
<div class="container">
<header>
<h1>GLM-TTS æµå¼è¯­éŸ³åˆæˆ</h1>
<p class="subtitle">çœŸæ­£çš„è¾¹ç”Ÿæˆè¾¹æ’­æ”¾ï¼Œå®Œæ•´æ§åˆ¶åŠŸèƒ½</p>
</header>
<div class="config-section">
<h2>ğŸ”Š è¯­éŸ³é…ç½®</h2>
<div class="config-grid">
<div class="form-group">
<label for="text">è¦åˆæˆçš„æ–‡æœ¬</label>
<textarea id="text" placeholder="è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬...">ä½ å¥½ï¼Œè¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ–‡æœ¬ã€‚æµå¼ä¼ è¾“å…è®¸è¾¹ç”Ÿæˆè¾¹æ’­æ”¾ï¼Œå¤§å¤§æå‡ç”¨æˆ·ä½“éªŒã€‚ä½ å¯ä»¥è¾“å…¥æ›´é•¿çš„æ–‡æœ¬ï¼Œä½“éªŒçœŸæ­£çš„å®æ—¶è¯­éŸ³åˆæˆæ•ˆæœã€‚</textarea>
</div>
<div class="form-group">
<label for="voiceType">éŸ³è‰²ç±»å‹</label>
<div class="voice-options">
<div class="voice-option">
<input type="radio" id="builtin" name="voiceType" value="builtin" checked>
<label for="builtin">å†…ç½®éŸ³è‰²</label>
</div>
<div class="voice-option">
<input type="radio" id="upload" name="voiceType" value="upload">
<label for="upload">ä¸Šä¼ éŸ³è‰²</label>
</div>
</div>
</div>
<div class="form-group" id="builtinVoiceGroup">
<label for="builtinVoiceId">å†…ç½®éŸ³è‰²ID</label>
<select id="builtinVoiceId">
<option value="default">é»˜è®¤éŸ³è‰²</option>
<!-- å…¶ä»–éŸ³è‰²å¯ä»¥é€šè¿‡APIåŠ¨æ€è·å– -->
</select>
</div>
<div class="form-group" id="uploadVoiceGroup" style="display: none;">
<label for="promptAudio">ä¸Šä¼ å‚è€ƒéŸ³é¢‘</label>
<input type="file" id="promptAudio" accept="audio/wav,audio/mp3">
<div class="upload-preview" id="uploadPreview">
<div class="upload-info">å·²é€‰æ‹©éŸ³é¢‘æ–‡ä»¶ï¼š<span id="fileName"></span></div>
<audio controls id="audioPreview"></audio>
</div>
</div>
<div class="form-group">
<label for="promptText">å‚è€ƒéŸ³é¢‘æ–‡æœ¬</label>
<input type="text" id="promptText" value="æˆ‘çœ‹äº†ç–¯ç‹‚å…ƒç´ åŸï¼Œé‡Œè¾¹æ°´ç«å…ƒç´ è°ˆæ‹çˆ±çš„è®¾å®šå¾ˆå¦™ã€‚">
</div>
<div class="form-group">
<label for="sampleRate">é‡‡æ ·ç‡</label>
<select id="sampleRate">
<option value="24000" selected>24000 Hz (æ ‡å‡†)</option>
<option value="32000">32000 Hz (é«˜æ¸…)</option>
</select>
</div>
<div class="form-group">
<label for="chunkSize">å—å¤§å° (å­—èŠ‚)</label>
<select id="chunkSize">
<option value="128">128 (ä½å»¶è¿Ÿ)</option>
<option value="512">512 (å¹³è¡¡)</option>
<option value="1024" selected>1024 (æ¨è)</option>
<option value="4096">4096 (é«˜æ€§èƒ½)</option>
</select>
</div>
</div>
</div>
<div class="control-section">
<button id="synthesizeBtn" class="btn">ğŸ”Š å¼€å§‹åˆæˆå¹¶æ’­æ”¾</button>
</div>
<div class="player-section">
<h2>ğŸ§ æ’­æ”¾æ§åˆ¶</h2>
<div id="status" class="status info">å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»"å¼€å§‹åˆæˆå¹¶æ’­æ”¾"æŒ‰é’®</div>
<div class="progress-container">
<div>ä¸‹è½½è¿›åº¦: <span id="downloadProgressText">0%</span></div>
<div class="progress-bar" id="downloadProgressBar">
<div id="downloadProgressFill" class="progress-fill"></div>
</div>
</div>
<div class="stats">
<div class="stat-item">
<div class="stat-value" id="receivedBytes">0</div>
<div class="stat-label">å·²æ¥æ”¶ (å­—èŠ‚)</div>
</div>
<div class="stat-item">
<div class="stat-value" id="chunksCount">0</div>
<div class="stat-label">éŸ³é¢‘å—æ•°</div>
</div>
<div class="stat-item">
<div class="stat-value" id="estimatedDuration">0.0</div>
<div class="stat-label">ä¼°è®¡æ—¶é•¿ (ç§’)</div>
</div>
</div>
<div class="audio-player-container">
<div class="custom-audio-controls">
<button id="playPauseBtn" class="playback-btn" disabled>â–¶</button>
<div class="progress-container">
<div class="time-display">
<span id="currentTime">0.0</span> / <span id="totalTime">0.0</span>
</div>
<div class="progress-bar" id="playbackProgressBar">
<div id="playbackProgressFill" class="progress-fill"></div>
</div>
</div>
<div class="volume-control">
<span>ğŸ”Š</span>
<input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="0.8" class="volume-slider">
</div>
</div>
</div>
<div style="margin-top: 15px;">
<button id="downloadBtn" class="btn" disabled>ğŸ’¾ ä¸‹è½½å®Œæ•´éŸ³é¢‘</button>
</div>
</div>
</div>
<div class="footer">
<p>GLM-TTS æµå¼è¯­éŸ³åˆæˆæµ‹è¯•å®¢æˆ·ç«¯ | çœŸæ­£çš„è¾¹ç”Ÿæˆè¾¹æ’­æ”¾ä½“éªŒ</p>
</div>
<script>
// DOM å…ƒç´ 
const synthesizeBtn = document.getElementById('synthesizeBtn');
const playPauseBtn = document.getElementById('playPauseBtn');
const downloadBtn = document.getElementById('downloadBtn');
const statusEl = document.getElementById('status');
const downloadProgressFill = document.getElementById('downloadProgressFill');
const downloadProgressText = document.getElementById('downloadProgressText');
const playbackProgressFill = document.getElementById('playbackProgressFill');
const playbackProgressBar = document.getElementById('playbackProgressBar');
const currentTimeEl = document.getElementById('currentTime');
const totalTimeEl = document.getElementById('totalTime');
const receivedBytesEl = document.getElementById('receivedBytes');
const chunksCountEl = document.getElementById('chunksCount');
const estimatedDurationEl = document.getElementById('estimatedDuration');
const volumeSlider = document.getElementById('volumeSlider');
const builtinVoiceGroup = document.getElementById('builtinVoiceGroup');
const uploadVoiceGroup = document.getElementById('uploadVoiceGroup');
const promptAudioInput = document.getElementById('promptAudio');
const uploadPreview = document.getElementById('uploadPreview');
const fileNameEl = document.getElementById('fileName');
const audioPreview = document.getElementById('audioPreview');
const downloadProgressBar = document.getElementById('downloadProgressBar');

// çŠ¶æ€å˜é‡
let isSynthesizing = false;
let isPlaying = false;
let audioContext = null;
let gainNode = null;
let audioChunks = [];  // ç”¨äºä¸‹è½½çš„åŸå§‹å­—èŠ‚æ•°æ®
let pcmData = [];      // ç”¨äºæ’­æ”¾çš„PCMæ•°æ®
let totalBytes = 0;
let chunkCount = 0;
let startTime = 0;
let sampleRate = 24000;
let uploadedAudioBlob = null;
let estimatedTotalChunks = 0;
let audioBlobUrl = null;
let isPlaybackReady = false;
let playbackPosition = 0; // æ’­æ”¾ä½ç½®ï¼ˆç§’ï¼‰
let lastUpdateTime = 0;
let animationFrameId = null;
let wavHeaderSkipped = false;
let activeSources = []; // è·Ÿè¸ªæ‰€æœ‰æ´»åŠ¨çš„éŸ³é¢‘æº
let isStreamComplete = false; // æ ‡è®°æµæ˜¯å¦å®Œæˆ
let isUserPaused = false; // æ ‡è®°æ˜¯å¦æ˜¯ç”¨æˆ·ä¸»åŠ¨æš‚åœ
let pendingPlayTimeout = null; // å¾…å¤„ç†çš„æ’­æ”¾è¶…æ—¶
let audioCache = new Uint8Array(0); // éŸ³é¢‘æ•°æ®ç¼“å­˜ï¼Œç”¨äºå¤„ç†å­—èŠ‚å¯¹é½é—®é¢˜
let audioQueue = []; // éŸ³é¢‘æ’­æ”¾é˜Ÿåˆ—
let isQueueProcessing = false; // æ ‡è®°æ˜¯å¦æ­£åœ¨å¤„ç†é˜Ÿåˆ—
let currentPlaybackStartTime = 0; // å½“å‰æ’­æ”¾ç‰‡æ®µçš„å¼€å§‹æ—¶é—´ï¼ˆç§’ï¼‰
let lastProcessedSampleIndex = 0; // æœ€åå¤„ç†çš„æ ·æœ¬ç´¢å¼•

// åˆå§‹åŒ–
async function init() {
    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
    if (!window.AudioContext && !window.webkitAudioContext) {
        showError('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWeb Audio APIï¼Œæ— æ³•è¿›è¡ŒéŸ³é¢‘æ’­æ”¾ã€‚è¯·ä½¿ç”¨Chromeã€Firefoxæˆ–Edgeæµè§ˆå™¨ã€‚');
        synthesizeBtn.disabled = true;
        return;
    }
    
    // äº‹ä»¶ç›‘å¬
    synthesizeBtn.addEventListener('click', startSynthesis);
    playPauseBtn.addEventListener('click', togglePlayPause);
    downloadBtn.addEventListener('click', downloadAudio);
    playbackProgressBar.addEventListener('click', handleProgressClick);
    volumeSlider.addEventListener('input', handleVolumeChange);
    
    // éŸ³è‰²ç±»å‹åˆ‡æ¢
    document.querySelectorAll('input[name="voiceType"]').forEach(radio => {
        radio.addEventListener('change', function() {
            builtinVoiceGroup.style.display = this.value === 'builtin' ? 'block' : 'none';
            uploadVoiceGroup.style.display = this.value === 'upload' ? 'block' : 'none';
        });
    });
    
    // ä¸Šä¼ éŸ³é¢‘å¤„ç†
    promptAudioInput.addEventListener('change', handleAudioUpload);
    
    // è®¾ç½®CORSä»£ç†ï¼ˆå¦‚æœéœ€è¦ï¼‰
    setupCorsProxy();
    
    // åˆå§‹çŠ¶æ€
    updateButtonStates();
}

// æ›´æ–°æŒ‰é’®çŠ¶æ€
function updateButtonStates() {
    synthesizeBtn.disabled = isSynthesizing;
    playPauseBtn.disabled = !isPlaybackReady || audioChunks.length === 0;
    downloadBtn.disabled = !isStreamComplete;
    playPauseBtn.innerHTML = isPlaying ? 'â¸' : 'â–¶';
}

// å¤„ç†éŸ³é¢‘ä¸Šä¼ 
function handleAudioUpload(event) {
    const file = event.target.files[0];
    if (!file) {
        uploadPreview.style.display = 'none';
        uploadedAudioBlob = null;
        return;
    }
    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
    const validTypes = ['audio/wav', 'audio/x-wav', 'audio/mp3', 'audio/mpeg'];
    if (!validTypes.includes(file.type)) {
        showError('ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼ã€‚è¯·ä¸Šä¼ WAVæˆ–MP3æ–‡ä»¶ã€‚');
        promptAudioInput.value = '';
        return;
    }
    // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶5MBï¼‰
    if (file.size > 5 * 1024 * 1024) {
        showError('éŸ³é¢‘æ–‡ä»¶å¤ªå¤§ã€‚æœ€å¤§é™åˆ¶5MBã€‚');
        promptAudioInput.value = '';
        return;
    }
    // æ˜¾ç¤ºé¢„è§ˆ
    fileNameEl.textContent = file.name;
    uploadPreview.style.display = 'block';
    // åˆ›å»ºé¢„è§ˆURL
    const url = URL.createObjectURL(file);
    audioPreview.src = url;
    // ä¿å­˜æ–‡ä»¶
    uploadedAudioBlob = file;
    setStatus(`âœ… å·²ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶: ${file.name} (${formatBytes(file.size)})`, 'success');
}

// è®¾ç½®CORSä»£ç†
function setupCorsProxy() {
    // å¦‚æœAPIåœ¨ä¸åŒåŸŸï¼Œå¯ä»¥è®¾ç½®ä»£ç†
    const apiUrl = 'http://localhost:8809/tts/stream';
    // åœ¨å®é™…éƒ¨ç½²æ—¶ï¼Œå¯èƒ½éœ€è¦é…ç½®CORSæˆ–ä½¿ç”¨ä»£ç†
    // æ£€æŸ¥æ˜¯å¦åŒæº
    const apiHost = new URL(apiUrl).host;
    const currentHost = window.location.host;
    if (apiHost !== currentHost) {
        console.log('APIåœ¨ä¸åŒåŸŸï¼Œå¯èƒ½éœ€è¦CORSé…ç½®');
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œå¯ä»¥è®¾ç½®ä»£ç†æˆ–æç¤ºç”¨æˆ·
    }
}

// åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
async function createAudioContext() {
    try {
        if (audioContext) {
            try {
                // å…ˆåœæ­¢æ‰€æœ‰æ´»åŠ¨æº
                activeSources.forEach(source => {
                    if (source && source.stop) {
                        try {
                            source.stop(0);
                        } catch (e) {
                            console.log('Error stopping source:', e);
                        }
                    }
                });
                activeSources = [];
                // å…³é—­ç°æœ‰ä¸Šä¸‹æ–‡
                await audioContext.close();
            } catch (e) {
                console.log('Error closing existing audio context:', e);
            }
        }
        // åˆ›å»ºæ–°ä¸Šä¸‹æ–‡
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioContext.createGain();
        gainNode.gain.value = parseFloat(volumeSlider.value);
        gainNode.connect(audioContext.destination);
        console.log('AudioContext initialized with sample rate:', audioContext.sampleRate);
        return true;
    } catch (error) {
        console.error('Error creating AudioContext:', error);
        return false;
    }
}

// å¼€å§‹åˆæˆ
async function startSynthesis() {
    if (isSynthesizing) return;
    isSynthesizing = true;
    isPlaying = false;
    isUserPaused = false; // é‡ç½®ç”¨æˆ·æš‚åœçŠ¶æ€
    isPlaybackReady = false;
    audioChunks = [];
    pcmData = [];
    totalBytes = 0;
    chunkCount = 0;
    startTime = Date.now();
    estimatedTotalChunks = 0;
    playbackPosition = 0;
    wavHeaderSkipped = false;
    activeSources = [];
    isStreamComplete = false;
    audioCache = new Uint8Array(0); // é‡ç½®éŸ³é¢‘ç¼“å­˜
    audioQueue = []; // é‡ç½®æ’­æ”¾é˜Ÿåˆ—
    isQueueProcessing = false;
    currentPlaybackStartTime = 0;
    lastProcessedSampleIndex = 0;
    
    // é‡ç½®UI
    resetUI();
    setStatus('æ­£åœ¨åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ...', 'processing');
    updateButtonStates();
    
    try {
        // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
        const audioContextCreated = await createAudioContext();
        if (!audioContextCreated) {
            throw new Error('æ— æ³•åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ');
        }
        
        // éªŒè¯éŸ³è‰²é€‰æ‹©
        const voiceType = document.querySelector('input[name="voiceType"]:checked').value;
        if (voiceType === 'upload' && !uploadedAudioBlob) {
            throw new Error('è¯·å…ˆä¸Šä¼ å‚è€ƒéŸ³é¢‘æ–‡ä»¶');
        }
        
        // æ”¶é›†è¡¨å•æ•°æ®
        const formData = new FormData();
        formData.append('text', document.getElementById('text').value);
        formData.append('uttid', `web_${Date.now()}`);
        formData.append('voice_type', voiceType);
        if (voiceType === 'builtin') {
            formData.append('builtin_voice_id', document.getElementById('builtinVoiceId').value);
        }
        formData.append('prompt_text', document.getElementById('promptText').value);
        sampleRate = parseInt(document.getElementById('sampleRate').value);
        formData.append('sample_rate', sampleRate);
        formData.append('chunk_size', document.getElementById('chunkSize').value);
        
        // æ·»åŠ ä¸Šä¼ çš„éŸ³é¢‘æ–‡ä»¶
        if (voiceType === 'upload' && uploadedAudioBlob) {
            formData.append('prompt_audio', uploadedAudioBlob);
        }
        
        // å¼€å§‹æµå¼è¯·æ±‚
        setStatus('æ­£åœ¨è¿æ¥TTSæœåŠ¡...', 'processing');
        const response = await fetch('http://localhost:8809/tts/stream', {
            method: 'POST',
            body: formData,
            headers: {
                'Accept': 'audio/wav'
            }
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error! status: ${response.status}, ${errorText}`);
        }
        
        setStatus('âœ… å·²è¿æ¥ï¼Œå¼€å§‹æ¥æ”¶éŸ³é¢‘æµ...', 'success');
        
        // å¤„ç†æµå¼å“åº”
        const reader = response.body.getReader();
        const wavHeaderLength = 44; // æ ‡å‡†WAVå¤´é•¿åº¦
        
        while (true) {
            if (!isSynthesizing) {
                reader.cancel();
                break;
            }
            
            const { done, value } = await reader.read();
            
            if (done) {
                // æµå®Œæˆ
                isStreamComplete = true;
                // å¤„ç†ç¼“å­˜ä¸­å‰©ä½™çš„æ•°æ®
                if (audioCache.length > 0) {
                    await processAudioChunk(audioCache);
                    audioCache = new Uint8Array(0);
                }
                setDownloadProgress(100); // è®¾ç½®ä¸‹è½½è¿›åº¦ä¸º100%
                setStatus('âœ… éŸ³é¢‘æµå®Œæˆï¼Œå‡†å¤‡æ’­æ”¾å®Œæ•´éŸ³é¢‘', 'success');
                isSynthesizing = false;
                updateButtonStates();
                // æ›´æ–°æ€»æ—¶é•¿
                const totalSamples = pcmData.length;
                const totalDuration = totalSamples / sampleRate;
                totalTimeEl.textContent = totalDuration.toFixed(1);
                
                // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œç¡®ä¿é˜Ÿåˆ—å¤„ç†å®Œæˆ
                if (isPlaying && !isQueueProcessing) {
                    processAudioQueue();
                }
                break;
            }
            
            if (value && value.length > 0) {
                let audioData = value;
                
                // è·³è¿‡WAVå¤´ï¼ˆåªè·³è¿‡ä¸€æ¬¡ï¼‰
                if (!wavHeaderSkipped && value.length >= wavHeaderLength) {
                    audioData = value.slice(wavHeaderLength);
                    wavHeaderSkipped = true;
                    console.log('è·³è¿‡äº†WAVæ–‡ä»¶å¤´');
                }
                
                if (audioData.length > 0) {
                    await processAudioChunk(audioData);
                    
                    // ç¬¬ä¸€ä¸ªå—åˆ°è¾¾åå¯ç”¨æ’­æ”¾æŒ‰é’®
                    if (!isPlaybackReady) {
                        isPlaybackReady = true;
                        updateButtonStates();
                        setStatus('âœ… é¦–å—éŸ³é¢‘å·²åˆ°è¾¾ï¼Œå¯ä»¥å¼€å§‹æ’­æ”¾', 'success');
                    }
                    
                    // é¿å…é˜»å¡ä¸»çº¿ç¨‹
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
        }
    } catch (error) {
        console.error('åˆæˆè¿‡ç¨‹ä¸­å‡ºé”™:', error);
        showError(`åˆæˆå¤±è´¥: ${error.message}`);
        isSynthesizing = false;
        updateButtonStates();
        
        // æ¸…ç†ç¼“å­˜
        audioCache = new Uint8Array(0);
    }
}

// å¤„ç†éŸ³é¢‘å— - ä½¿ç”¨ç¼“å­˜æœºåˆ¶
async function processAudioChunk(chunk) {
    if (!isSynthesizing && !isPlaying) return;
    
    // å°†æ–°æ•°æ®ä¸ç¼“å­˜åˆå¹¶
    const combinedData = new Uint8Array(audioCache.length + chunk.length);
    combinedData.set(audioCache, 0);
    combinedData.set(chunk, audioCache.length);
    
    // è®¡ç®—å®Œæ•´16ä½æ ·æœ¬çš„æ•°é‡
    const completeSamples = Math.floor(combinedData.length / 2);
    const bytesToProcess = completeSamples * 2;
    
    // å¦‚æœæœ‰å®Œæ•´æ ·æœ¬å¯ä»¥å¤„ç†
    if (bytesToProcess > 0) {
        // æå–è¦å¤„ç†çš„å®Œæ•´æ•°æ®
        const processData = combinedData.slice(0, bytesToProcess);
        
        // ç´¯è®¡ç»Ÿè®¡
        totalBytes += processData.length;
        chunkCount++;
        
        try {
            // å®‰å…¨åœ°å°†å­—èŠ‚æ•°æ®è½¬æ¢ä¸ºInt16Array
            const buffer = new ArrayBuffer(processData.length);
            const view = new Uint8Array(buffer);
            view.set(processData);
            const int16Array = new Int16Array(buffer);
            
            // ä¿å­˜PCMæ•°æ®
            const startIndex = pcmData.length;
            for (let i = 0; i < int16Array.length; i++) {
                pcmData.push(int16Array[i]);
            }
            const endIndex = pcmData.length;
            
            // å­˜å‚¨å—ç”¨äºä¸‹è½½ï¼ˆä¿ç•™åŸå§‹å­—èŠ‚æ•°æ®ï¼‰
            audioChunks.push(new Uint8Array(processData));
            
            // å°†æ–°æ•°æ®åŠ å…¥æ’­æ”¾é˜Ÿåˆ—
            addToAudioQueue(startIndex, endIndex);
        } catch (error) {
            console.error('è½¬æ¢ä¸ºInt16Arrayæ—¶å‡ºé”™:', error);
            // ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆï¼Œæ‰‹åŠ¨å¤„ç†
            const startIndex = pcmData.length;
            for (let i = 0; i < processData.length - 1; i += 2) {
                // æ‰‹åŠ¨ç»„åˆä¸¤ä¸ªå­—èŠ‚ä¸ºä¸€ä¸ª16ä½æ•´æ•°ï¼ˆå°ç«¯åºï¼‰
                const sample = processData[i] | (processData[i + 1] << 8);
                // è½¬æ¢ä¸ºæœ‰ç¬¦å·16ä½æ•´æ•°
                const signedSample = sample > 32767 ? sample - 65536 : sample;
                pcmData.push(signedSample);
            }
            const endIndex = pcmData.length;
            
            // å°†æ–°æ•°æ®åŠ å…¥æ’­æ”¾é˜Ÿåˆ—
            addToAudioQueue(startIndex, endIndex);
        }
        
        // æ›´æ–°UI
        updateStats();
    }
    
    // ä¿å­˜å‰©ä½™çš„ä¸å®Œæ•´æ•°æ®åˆ°ç¼“å­˜
    if (combinedData.length > bytesToProcess) {
        audioCache = combinedData.slice(bytesToProcess);
    } else {
        audioCache = new Uint8Array(0);
    }
}

// å°†éŸ³é¢‘æ•°æ®åŠ å…¥æ’­æ”¾é˜Ÿåˆ—
function addToAudioQueue(startIndex, endIndex) {
    if (startIndex >= endIndex) return;
    
    audioQueue.push({
        startIndex: startIndex,
        endIndex: endIndex,
        position: startIndex / sampleRate // èµ·å§‹ä½ç½®ï¼ˆç§’ï¼‰
    });
    
    console.log(`æ·»åŠ åˆ°é˜Ÿåˆ—: ${startIndex}-${endIndex} (ä½ç½®: ${startIndex/sampleRate.toFixed(2)}s)`);
    
    // å¦‚æœæ­£åœ¨æ’­æ”¾ä¸”æ²¡æœ‰åœ¨å¤„ç†é˜Ÿåˆ—ï¼Œå¼€å§‹å¤„ç†
    if (isPlaying && !isUserPaused && !isQueueProcessing) {
        processAudioQueue();
    }
}

// å¤„ç†éŸ³é¢‘æ’­æ”¾é˜Ÿåˆ—
function processAudioQueue() {
    if (isQueueProcessing || audioQueue.length === 0 || !isPlaying || isUserPaused) {
        return;
    }
    
    isQueueProcessing = true;
    
    // è·å–é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªç‰‡æ®µ
    const segment = audioQueue[0];
    
    // æ£€æŸ¥æ˜¯å¦åº”è¯¥æ’­æ”¾è¿™ä¸ªç‰‡æ®µ
    const segmentStartTime = segment.position;
    const segmentDuration = (segment.endIndex - segment.startIndex) / sampleRate;
    const segmentEndTime = segmentStartTime + segmentDuration;
    
    console.log(`å¤„ç†é˜Ÿåˆ—: å½“å‰ä½ç½®=${playbackPosition.toFixed(2)}s, ç‰‡æ®µä½ç½®=${segmentStartTime.toFixed(2)}-${segmentEndTime.toFixed(2)}s`);
    
    if (playbackPosition < segmentStartTime - 0.1) {
        // è¿˜æ²¡åˆ°æ’­æ”¾è¿™ä¸ªç‰‡æ®µçš„æ—¶é—´ï¼Œç­‰å¾…
        isQueueProcessing = false;
        setTimeout(processAudioQueue, 100);
        return;
    }
    
    // æ’­æ”¾è¿™ä¸ªç‰‡æ®µ
    playAudioSegment(segment.startIndex, segment.endIndex)
        .then(() => {
            // æ’­æ”¾å®Œæˆåï¼Œä»é˜Ÿåˆ—ä¸­ç§»é™¤
            audioQueue.shift();
            isQueueProcessing = false;
            
            // æ›´æ–°æ’­æ”¾ä½ç½®
            playbackPosition = segmentEndTime;
            currentTimeEl.textContent = playbackPosition.toFixed(1);
            const totalDuration = pcmData.length / sampleRate;
            if (totalDuration > 0) {
                const progress = (playbackPosition / totalDuration) * 100;
                playbackProgressFill.style.width = `${Math.min(100, progress)}%`;
            }
            
            console.log(`ç‰‡æ®µæ’­æ”¾å®Œæˆ: ${segmentStartTime.toFixed(2)}-${segmentEndTime.toFixed(2)}s, å½“å‰ä½ç½®=${playbackPosition.toFixed(2)}s`);
            
            // æ£€æŸ¥æ˜¯å¦æ’­æ”¾å®Œæˆ
            if (isStreamComplete && audioQueue.length === 0 && playbackPosition >= totalDuration - 0.1) {
                isPlaying = false;
                isUserPaused = false;
                updateButtonStates();
                setStatus('âœ… æ’­æ”¾å®Œæˆ', 'success');
                return;
            }
            
            // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªç‰‡æ®µ
            if (audioQueue.length > 0) {
                setTimeout(processAudioQueue, 10);
            }
        })
        .catch(error => {
            console.error('æ’­æ”¾ç‰‡æ®µæ—¶å‡ºé”™:', error);
            audioQueue.shift(); // ç§»é™¤å‡ºé”™çš„ç‰‡æ®µ
            isQueueProcessing = false;
            if (audioQueue.length > 0) {
                setTimeout(processAudioQueue, 100);
            }
        });
}

// æ’­æ”¾éŸ³é¢‘ç‰‡æ®µ - è¿”å›Promise
function playAudioSegment(startSample, endSample) {
    return new Promise((resolve, reject) => {
        if (startSample >= endSample || !audioContext) {
            resolve();
            return;
        }
        
        try {
            const bufferLength = endSample - startSample;
            if (bufferLength <= 0) {
                resolve();
                return;
            }
            
            const audioBuffer = audioContext.createBuffer(1, bufferLength, sampleRate);
            const channelData = audioBuffer.getChannelData(0);
            
            // å¡«å……éŸ³é¢‘æ•°æ®
            for (let i = 0; i < bufferLength; i++) {
                channelData[i] = pcmData[startSample + i] / 32768.0;
            }
            
            // åˆ›å»ºéŸ³é¢‘æº
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(gainNode);
            
            // è·Ÿè¸ªæ´»åŠ¨æº
            activeSources.push(source);
            
            // ä½¿ç”¨å½“å‰ä¸Šä¸‹æ–‡æ—¶é—´
            source.start(audioContext.currentTime);
            
            source.onended = function() {
                // ä»æ´»åŠ¨æºä¸­ç§»é™¤
                activeSources = activeSources.filter(s => s !== source);
                resolve();
            };
            
            source.onerror = function(error) {
                activeSources = activeSources.filter(s => s !== source);
                reject(error);
            };
        } catch (error) {
            reject(error);
        }
    });
}

// åˆ‡æ¢æ’­æ”¾/æš‚åœ
function togglePlayPause() {
    if (!isPlaybackReady) {
        showError('è¯·ç­‰å¾…éŸ³é¢‘æ•°æ®å¼€å§‹æ¥æ”¶');
        return;
    }
    
    // æ¸…é™¤ä»»ä½•å¾…å¤„ç†çš„æ’­æ”¾æ“ä½œ
    if (pendingPlayTimeout) {
        clearTimeout(pendingPlayTimeout);
        pendingPlayTimeout = null;
    }
    
    if (isPlaying) {
        // ç”¨æˆ·ä¸»åŠ¨æš‚åœ
        isUserPaused = true;
        pausePlayback();
    } else {
        // ç”¨æˆ·ä¸»åŠ¨æ’­æ”¾
        isUserPaused = false;
        startPlayback();
    }
}

// startPlayback å‡½æ•°
async function startPlayback() {
    if (!pcmData.length) return;
    if (isPlaying) return; // é˜²æ­¢é‡å¤è°ƒç”¨
    
    // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡æ˜¯è¿è¡ŒçŠ¶æ€
    if (audioContext && audioContext.state === 'suspended') {
        try {
            await audioContext.resume();
        } catch (error) {
            console.error('Error resuming audio context:', error);
            showError('æ¢å¤éŸ³é¢‘å¤±è´¥: ' + error.message);
            return;
        }
    }
    
    isPlaying = true;
    isUserPaused = false;
    updateButtonStates();
    setStatus('â–¶ æ­£åœ¨æ’­æ”¾...', 'success');
    
    // é‡æ–°è®¡ç®—æ€»æ—¶é•¿
    const totalDuration = pcmData.length / sampleRate;
    
    // é‡ç½®æ’­æ”¾ä½ç½®å¦‚æœå·²ç»æ’­æ”¾å®Œæˆ
    if (playbackPosition >= totalDuration - 0.1) {
        playbackPosition = 0;
        currentTimeEl.textContent = '0.0';
        playbackProgressFill.style.width = '0%';
    }
    
    // ç¡®ä¿æ’­æ”¾ä½ç½®åœ¨æœ‰æ•ˆèŒƒå›´å†…
    playbackPosition = Math.max(0, Math.min(playbackPosition, totalDuration));
    
    // å¼€å§‹æ›´æ–°æ’­æ”¾æ—¶é—´
    lastUpdateTime = performance.now();
    updatePlaybackTime();
    
    // å¼€å§‹å¤„ç†éŸ³é¢‘é˜Ÿåˆ—
    processAudioQueue();
}

// æš‚åœæ’­æ”¾
function pausePlayback() {
    // æ¸…é™¤ä»»ä½•å¾…å¤„ç†çš„æ’­æ”¾æ“ä½œ
    if (pendingPlayTimeout) {
        clearTimeout(pendingPlayTimeout);
        pendingPlayTimeout = null;
    }
    
    if (!isPlaying) return;
    
    isUserPaused = true;
    isPlaying = false;
    isQueueProcessing = false; // åœæ­¢é˜Ÿåˆ—å¤„ç†
    
    updateButtonStates();
    setStatus('â¸ æ’­æ”¾å·²æš‚åœ', 'info');
    
    // åœæ­¢æ‰€æœ‰æ´»åŠ¨çš„éŸ³é¢‘æº
    activeSources.forEach(source => {
        if (source && source.stop) {
            try {
                source.stop(0);
            } catch (e) {
                console.log('Error stopping source during pause:', e);
            }
        }
    });
    activeSources = [];
    
    // æŒ‚èµ·éŸ³é¢‘ä¸Šä¸‹æ–‡
    if (audioContext) {
        audioContext.suspend().catch(error => {
            console.error('Error suspending audio context:', error);
        });
    }
    
    cancelAnimationFrame(animationFrameId);
}

// æ›´æ–°æ’­æ”¾æ—¶é—´
function updatePlaybackTime() {
    if (!isPlaying || isUserPaused) {
        cancelAnimationFrame(animationFrameId);
        return;
    }
    
    const now = performance.now();
    const elapsed = (now - lastUpdateTime) / 1000; // è½¬æ¢ä¸ºç§’
    
    if (elapsed > 0) {
        // ä¸è¦åœ¨è¿™é‡Œæ›´æ–° playbackPositionï¼Œå› ä¸ºé˜Ÿåˆ—æ’­æ”¾ä¼šç²¾ç¡®æ§åˆ¶ä½ç½®
        // åªæ›´æ–°æ˜¾ç¤º
        const totalDuration = pcmData.length / sampleRate;
        currentTimeEl.textContent = Math.min(playbackPosition, totalDuration).toFixed(1);
        
        // æ›´æ–°è¿›åº¦æ¡
        if (totalDuration > 0) {
            const progress = (playbackPosition / totalDuration) * 100;
            playbackProgressFill.style.width = `${Math.min(100, progress)}%`;
        }
    }
    
    lastUpdateTime = now;
    animationFrameId = requestAnimationFrame(updatePlaybackTime);
}

// å¤„ç†è¿›åº¦æ¡ç‚¹å‡»
function handleProgressClick(e) {
    if (!isPlaybackReady || pcmData.length === 0) return;
    
    // æ¸…é™¤ä»»ä½•å¾…å¤„ç†çš„æ’­æ”¾æ“ä½œ
    if (pendingPlayTimeout) {
        clearTimeout(pendingPlayTimeout);
        pendingPlayTimeout = null;
    }
    
    // è®°å½•å½“å‰æ’­æ”¾çŠ¶æ€
    const wasPlaying = isPlaying;
    const wasUserPaused = isUserPaused;
    
    // æš‚åœå½“å‰æ’­æ”¾
    if (isPlaying) {
        pausePlayback();
    }
    
    const rect = playbackProgressBar.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const percent = Math.max(0, Math.min(100, (clickX / rect.width) * 100));
    
    // è®¡ç®—æ–°çš„æ’­æ”¾ä½ç½®
    const totalDuration = pcmData.length / sampleRate;
    let newPosition = (percent / 100) * totalDuration;
    
    // ç¡®ä¿ä¸è·³è½¬åˆ°æœªä¸‹è½½çš„ä½ç½®
    if (!isStreamComplete) {
        const availableDuration = pcmData.length / sampleRate;
        newPosition = Math.min(newPosition, availableDuration);
    }
    
    // ç¡®ä¿ä½ç½®åœ¨æœ‰æ•ˆèŒƒå›´å†…
    newPosition = Math.max(0, Math.min(newPosition, totalDuration));
    
    // æ›´æ–°æ’­æ”¾ä½ç½®
    playbackPosition = newPosition;
    currentTimeEl.textContent = newPosition.toFixed(1);
    
    if (totalDuration > 0) {
        const progress = (newPosition / totalDuration) * 100;
        playbackProgressFill.style.width = `${Math.min(100, progress)}%`;
    }
    
    // æ¸…ç©ºé˜Ÿåˆ—å¹¶é‡æ–°å¼€å§‹
    audioQueue = [];
    isQueueProcessing = false;
    
    // è®¡ç®—å¯¹åº”çš„æ ·æœ¬ç´¢å¼•
    const sampleIndex = Math.floor(newPosition * sampleRate);
    lastProcessedSampleIndex = sampleIndex;
    
    // é‡å»ºé˜Ÿåˆ—ï¼šå°†æ‰€æœ‰åœ¨æ–°ä½ç½®ä¹‹åçš„ç‰‡æ®µåŠ å…¥é˜Ÿåˆ—
    if (sampleIndex < pcmData.length) {
        const remainingSamples = pcmData.length - sampleIndex;
        if (remainingSamples > 0) {
            audioQueue.push({
                startIndex: sampleIndex,
                endIndex: pcmData.length,
                position: newPosition
            });
        }
    }
    
    // æ¢å¤æ’­æ”¾çŠ¶æ€
    if (wasPlaying && !wasUserPaused) {
        isUserPaused = false;
        isPlaying = true;
        updateButtonStates();
        processAudioQueue();
    } else if (wasUserPaused) {
        isUserPaused = true; // ä¿æŒæš‚åœçŠ¶æ€
    }
    
    setStatus(`â© å·²è·³è½¬åˆ° ${newPosition.toFixed(1)} ç§’`, 'info');
}

// å¤„ç†éŸ³é‡å˜åŒ–
function handleVolumeChange() {
    if (gainNode) {
        gainNode.gain.value = parseFloat(volumeSlider.value);
    }
}

// æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
function updateStats() {
    receivedBytesEl.textContent = formatBytes(totalBytes);
    chunksCountEl.textContent = chunkCount;
    
    // ä¼°è®¡æ—¶é•¿
    const totalSamples = pcmData.length;
    const estimatedDuration = totalSamples / sampleRate;
    estimatedDurationEl.textContent = estimatedDuration.toFixed(1);
    totalTimeEl.textContent = estimatedDuration.toFixed(1);
    
    // æ›´æ–°ä¸‹è½½è¿›åº¦
    let downloadProgress = 0;
    if (isStreamComplete) {
        downloadProgress = 100;
    } else if (estimatedTotalChunks > 0) {
        // åŸºäºå—æ•°çš„è¿›åº¦
        downloadProgress = Math.min(99, Math.floor((chunkCount / estimatedTotalChunks) * 100));
    } else {
        // åŸºäºæ—¶é—´çš„è¿›åº¦ï¼ˆå‡è®¾æœ€å¤§10ç§’ï¼‰
        const elapsed = Date.now() - startTime;
        const maxTime = 10000; // 10ç§’
        downloadProgress = Math.min(99, Math.floor((elapsed / maxTime) * 100));
    }
    
    // ç¡®ä¿æœ‰è¿›åº¦æ˜¾ç¤º
    if (downloadProgress < 5 && chunkCount > 0) {
        downloadProgress = 5; // è‡³å°‘æ˜¾ç¤º5%è¡¨ç¤ºå·²ç»å¼€å§‹
    }
    
    setDownloadProgress(downloadProgress);
}

// è®¾ç½®ä¸‹è½½è¿›åº¦
function setDownloadProgress(percent) {
    const clampedPercent = Math.min(100, Math.max(0, percent));
    downloadProgressFill.style.width = `${clampedPercent}%`;
    downloadProgressText.textContent = `${clampedPercent.toFixed(1)}%`;
}

// ä¸‹è½½å®Œæ•´éŸ³é¢‘
function downloadAudio() {
    if (audioChunks.length === 0) return;
    
    try {
        // åˆå¹¶æ‰€æœ‰éŸ³é¢‘å—
        let totalLength = 0;
        for (const chunk of audioChunks) {
            totalLength += chunk.length;
        }
        
        // åˆ›å»ºå®Œæ•´çš„WAVæ–‡ä»¶
        const wavFile = createWavFile(audioChunks, totalLength, sampleRate);
        
        // åˆ›å»ºBlob URL
        const blob = new Blob([wavFile], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        
        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const a = document.createElement('a');
        a.href = url;
        a.download = `glm_tts_${new Date().toISOString().replace(/[:.]/g, '-')}.wav`;
        document.body.appendChild(a);
        a.click();
        
        // æ¸…ç†
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        setStatus('ğŸ’¾ éŸ³é¢‘æ–‡ä»¶å·²ä¸‹è½½', 'success');
    } catch (error) {
        console.error('ä¸‹è½½å¤±è´¥:', error);
        showError('ä¸‹è½½å¤±è´¥: ' + error.message);
    }
}

// åˆ›å»ºå®Œæ•´çš„WAVæ–‡ä»¶
function createWavFile(chunks, totalLength, sampleRate) {
    const numChannels = 1;
    const bitsPerSample = 16;
    const byteRate = sampleRate * numChannels * bitsPerSample / 8;
    const blockAlign = numChannels * bitsPerSample / 8;
    const dataSize = totalLength; // ä¸åŒ…æ‹¬WAVå¤´
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);
    
    // å†™å…¥WAVå¤´
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataSize, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true); // PCM format
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitsPerSample, true);
    writeString(view, 36, 'data');
    view.setUint32(40, dataSize, true);
    
    // å†™å…¥éŸ³é¢‘æ•°æ®
    let offset = 44;
    const audioView = new Uint8Array(buffer, 44);
    for (const chunk of chunks) {
        audioView.set(chunk, offset - 44);
        offset += chunk.length;
    }
    
    return buffer;
}

// å·¥å…·å‡½æ•°
function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function setStatus(message, type) {
    statusEl.textContent = message;
    statusEl.className = `status ${type}`;
}

function showError(message) {
    setStatus(`âŒ é”™è¯¯: ${message}`, 'error');
    console.error(message);
}

function resetUI() {
    setDownloadProgress(0);
    receivedBytesEl.textContent = '0';
    chunksCountEl.textContent = '0';
    estimatedDurationEl.textContent = '0.0';
    currentTimeEl.textContent = '0.0';
    totalTimeEl.textContent = '0.0';
    playbackProgressFill.style.width = '0%';
    playbackPosition = 0;
    isUserPaused = false;
    audioCache = new Uint8Array(0);
    audioQueue = [];
    isQueueProcessing = false;
    currentPlaybackStartTime = 0;
    lastProcessedSampleIndex = 0;
}

// åˆå§‹åŒ–é¡µé¢
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>